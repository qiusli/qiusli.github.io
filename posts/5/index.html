
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>李秋实的博客  | 逆旅，行人</title>

	<meta name="author" content="李秋实"> 
	
	<meta name="description" content="单件模式是最简单的一种设计模式，因为从头到尾都只涉及到一个类。单件模式想要达到的目的是在程序运行的过程中只创建一个类的对象，在很多场合这都很有用，比如注册表程序，你不会想要很多对象来，因为那样会造成混乱且很占内存，一个对象足矣。那么应该怎么应用单件模式呢？例子很简单，代码如下： Read on &hellip;"> <meta name="keywords" content="">

	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="逆旅，行人" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" rel="stylesheet" type="text/css">
	
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	
</head>



<body>
	<header id="header" class="inner"><h1>逆旅，行人</h1>
<nav id="main-nav"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/archives">Archive</a></li>
	<li><a href="/contact">Contact</a></li>
</ul>
</nav>


</header>

	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/13/singleton-pattern/">
		
			深入浅出设计模式之单件模式(Singleton Pattern)</a>
	</h2>
	<div class="entry-content">
		<p>单件模式是最简单的一种设计模式，因为从头到尾都只涉及到一个类。单件模式想要达到的目的是在程序运行的过程中只创建一个类的对象，在很多场合这都很有用，比如注册表程序，你不会想要很多对象来，因为那样会造成混乱且很占内存，一个对象足矣。那么应该怎么应用单件模式呢？例子很简单，代码如下：</p>


		
		<a href="/blog/2013/07/13/singleton-pattern/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-13T15:21:00-06:00" pubdate data-updated="true">Jul 13th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/13/factory-pattern/">
		
			深入浅出设计模式之工厂模式(Factory Method Pattern)</a>
	</h2>
	<div class="entry-content">
		<p>工厂模式算是设计模式中用到的最多的一类了，对于它最直观的描述就是：父类定义一个创建对象的接口，由子类决定需要创建什么对象，这样让类把实例化推迟到了子类。下面来举个例子来阐述吧。</p>

<p>有一个披萨店，可以做各种各样的披萨，但位于不同地方的分店里的披萨味道会有些不同。如果利用工厂模式，就是：</p>


		
		<a href="/blog/2013/07/13/factory-pattern/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-13T14:01:00-06:00" pubdate data-updated="true">Jul 13th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/12/decorator-pattern/">
		
			深入浅出设计模式之装饰器模式(Decorator Pattern)</a>
	</h2>
	<div class="entry-content">
		<p>今天该讲第三种设计模式 &ndash; 装饰器模式。同样，从名字就可以看出这种模式必定有一个基础组件，用来被修饰，也会有至少一个装饰器来修饰基础组件。同时要求被装饰器修饰过的组件对外界来说还是一个组件，只不过在被修饰之后多出了一些以前没有的功能。装饰器模式可以看做下图：</p>


		
		<a href="/blog/2013/07/12/decorator-pattern/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-12T14:53:00-06:00" pubdate data-updated="true">Jul 12th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/11/observer-pattern/">
		
			深入浅出设计模式之观察者模式(Observer Pattern)</a>
	</h2>
	<div class="entry-content">
		<p>观察者模式，顾名思义，这个模式中必定有观察者和被观察者。打一个形象的比喻，一些在证券交易市场的股民眼巴巴地看着自己买的股票所代表的公司能放些风声出来，这样自己就可以更好地把握这个消息做出买或卖的决定。而上市公司为了加强广大股民的信心，鼓励大家增持股票也会不断地放出例如公司的新项目马上出来了，大家赶紧买啊这些消息。我们暂且不论消息的真假，但这确实一个非常贴切的例子。</p>


		
		<a href="/blog/2013/07/11/observer-pattern/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-11T21:39:00-06:00" pubdate data-updated="true">Jul 11th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/11/strategy-pattern/">
		
			深入浅出设计模式之策略模式(Strategy Pattern)</a>
	</h2>
	<div class="entry-content">
		<p>今天开始阅读Head First设计模式，老早就听说这是一本经典书籍，但是这类华丽的辞藻确实听过太多，每每在阅读的时候发现自己也许期望太高了或者自己的水平不足，并没有带给自己耳目一新的感觉。但是今天在阅读这本书的时候，终于找到了一种久违的兴奋感，而它更来自于对书中内容的由浅入深的理解和阅读的乐趣。例如，在第一章讲解策略模式的时候，在读到书的最后一页之前，我并不知道自己学习的是哪种模式，所以在学习的过程中
我能完全静下心来理解纯粹的内容，而不是一边试图去记住“策略模式”这四个字，一边去看“策略”应用在哪里，而在这个过程中往往偏离了书本想要表达的内容，及作者期望读者走的学习道路，致使书本的作用大大降低。从引导读者这一点上来说，Head First设计模式这本书做得非常好！</p>


		
		<a href="/blog/2013/07/11/strategy-pattern/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-11T00:02:00-06:00" pubdate data-updated="true">Jul 11th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/09/tail-recursion/">
		
			一般递归与尾递归(Tail Recursion)</a>
	</h2>
	<div class="entry-content">
		<p>最近在读一篇文章的时候无意间接触到了尾递归，感觉他比一般的递归好用，有点意思，顾将之记录下来。</p>

<p>首先需要了解的是到底什么是尾递归？
这个问题其实很简单，顾名思义，尾递归就是在一个方法的尾部、且在函数返回前的最后一步调用函数本身。为了更好地理解，还是上代码吧(以著名的斐波拉契为例)：</p>


		
		<a href="/blog/2013/07/09/tail-recursion/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-09T21:58:00-06:00" pubdate data-updated="true">Jul 9th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/09/deep-copy-and-shallow-copy/">
		
			Java中对象的浅拷贝与深拷贝</a>
	</h2>
	<div class="entry-content">
		<p>Java中的拷贝方式分为深拷贝和浅拷贝。简单来说，深拷贝就是把一个对象中的所有值，如果被拷贝对象中有对其他对象的引用，那么这个引用指向的对象本身会被重新创建。浅拷贝和深拷贝类似，但是如果被拷贝对象中有对其他对象的引用，只是这个引用会被拷贝，而不是这个被引用的对象。</p>

<p>说起来有点绕口，那么我们就看看下面的图解吧：</p>

<p><img src="/images/deep_shallow_copy-1.png"></p>

<p>shallow copy:</p>

<p><img src="/images/deep_shallow_copy-2.png"></p>

<p>deep copy:</p>

<p><img src="/images/deep_shallow_copy-3.png"></p>


		
		<a href="/blog/2013/07/09/deep-copy-and-shallow-copy/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-09T19:17:00-06:00" pubdate data-updated="true">Jul 9th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/09/java-string-reside/">
		
			Java中的字符串驻留</a>
	</h2>
	<div class="entry-content">
		<p>最近在工作的时候，一句再正常不过的代码String a = “hello” + “world”;被改成了new StringBuilder().append(“hello”).append(“world”)；当时就比较疑惑这样做的好处，后来到网上查找了一番之后才清楚这与Java中的字符串驻留机制有关，那么什么是驻留呢？</p>


		
		<a href="/blog/2013/07/09/java-string-reside/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-09T19:11:00-06:00" pubdate data-updated="true">Jul 9th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/09/apprenticeship-pattern/">
		
			Apprenticeship Pattern读书笔记</a>
	</h2>
	<div class="entry-content">
		<p>花2个星期读完了这本书，作者是一名前ThoughtWorker，所以书里谈到的很多概念还是很清楚。</p>

<p>书本身非常好，里面谈到了从一名软件小工到专家的成长方法，这些方法都是读者能够拿之能用的。</p>


		
		<a href="/blog/2013/07/09/apprenticeship-pattern/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-09T19:06:00-06:00" pubdate data-updated="true">Jul 9th, 2013</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/technology/'>technology</a>

</div>


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/09/recursion/">
		
			递归的执行过程</a>
	</h2>
	<div class="entry-content">
		<p>这个问题困惑了我好久，从当初学习计算机开始就没有弄明白这个过程，只听说过能用迭代取代递归的地方就用迭代，因为递归很容易引起内存泄露。不过，作为一名专业的程序员，了解这些东西都是必不可少的，所以我今天就把它记录下来。 我们拿一个简单的程序来作为例子：</p>


		
		<a href="/blog/2013/07/09/recursion/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-09T18:42:00-06:00" pubdate data-updated="true">Jul 9th, 2013</time></div>
	


</div>
</article>


<nav id="pagenavi">
    
        <a href="4" class="prev">Prev</a>
    
    
        <a href="6" class="next">Next</a>
    
</nav>

</div>
	<footer id="footer" class="inner">Copyright &copy; 2015
 李秋实 
<br>
Powered by Octopress.
</footer>
	

</body>
</html>
