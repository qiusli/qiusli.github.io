<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 科技 | 逆旅，行人]]></title>
  <link href="http://qiusli.github.io/blog/categories/ke-ji/atom.xml" rel="self"/>
  <link href="http://qiusli.github.io/"/>
  <updated>2015-10-25T22:51:13-06:00</updated>
  <id>http://qiusli.github.io/</id>
  <author>
    <name><![CDATA[李秋实]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript中的继承]]></title>
    <link href="http://qiusli.github.io/blog/2015/10/25/js-inheritance/"/>
    <updated>2015-10-25T16:30:11-06:00</updated>
    <id>http://qiusli.github.io/blog/2015/10/25/js-inheritance</id>
    <content type="html"><![CDATA[<p>由于Javascript中的每个对象都有一个prototye,它也是对象的一个property.这个prototype也有自己的prototype,它能继承自那个prototype,而当前对象也能从自己的prototype那里继承property,这样就形成了一个prototype chain,这就是Javascript中继承的实现方式.简单来说,我们可以把当前对象的prototype(原型)看成是一个模板,当前对象继承自那个模板,然后扩充自己的方法.当前对象从其prototype那里获得一些property,而当前对象的prototype从其自身的prototype(prototype&rsquo;s prototype)那里也获得一些property.每一个通过Object literal或者new Object这种方式创建出的对象,其prototype指向object.prototype,意味着当前对象能获得object.prototype里的property.</p>

<pre><code class="Javascript">var book = {
    title: "red and black"
};
var p = Object.getPrototypeOf(book);
console.log(p == Object.prototype);   // true
</code></pre>

<p>所有对象都从Object.prototype那里继承了一些方法,最常见的有5个:<code>hasOwnProperty</code>, <code>propertyIsEnumerable</code>,<code>isPrototypeOf</code>,<code>valueOf</code>,<code>toString</code>.</p>

<p>实现继承最简单的方式就是显式指定当前对象的prototype(原型),这样它就能从其原型那里获得方法.我们可以使用Object.create()方法来实现这个目的,它会新创建一个对象,然后这个对象可以被赋值给一个变量.create第一个参数指定了谁是当前对象的原型,第二个参数是可选的,意味着一些自定义的property和其属性.</p>

<pre><code class="Javascript">// specify reference of prototypr of current object
var person1 = {name: "Qiushi"};
// is same as
var person2 = Object.create(Object.prototype, {
    name: {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Qiushi"
    }
});
</code></pre>

<pre><code class="Javascript">// inherit from other objects
var company = {
    name: "Goldman Sachs",
    sayName: function () {
        console.log("Company name is " + this.name)
    }
};
// anotherCompany自己定义了name property,它覆盖了从company那里继承来的name property.
var anotherCompany = Object.create(company, {
    name: {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ThoughtWorks"
    }
});
company.sayName();    // Company name is Goldman Sachs
anotherCompany.sayName();  // Company name is ThoughtWorks
console.log(company.hasOwnProperty("sayName")); // true
console.log(anotherCompany.hasOwnProperty("sayName")); // false
console.log(company.isPrototypeOf(anotherCompany)); // true
console.log(Object.getPrototypeOf(anotherCompany) == company); // true
var thirdCompany = Object.create(anotherCompany, {
    name: {
        configurable: true,
        writable: true,
        enumerable: true,
        value: "ThinkGeek"
    }
});
console.log(Object.getPrototypeOf(thirdCompany)); // { name: 'ThoughtWorks' }
</code></pre>

<p>下面这张图解释了原型链:</p>

<p><img src="/images/JS_inheritance/1.png"></p>

<p>当一个方法被调用时,系统会首先去当前对象的own property里寻找,如果找到了就返回,否则回去当前对象的prototype里寻找,如果找到就返回,否则继续去当前对象的prototype的prototype里继续寻找,这个寻找链的终结是Obejct.prototype.</p>

<p>有时候我们会想创建一个不继承自任何原型的对象,它在一些场景下很实用,例如被当做hash来用.</p>

<pre><code class="Javascript">var nakedObject = Object.create(null);console.log("toString" in nakedObject);     // falseconsole.log("valueOf" in nakedObject);      // false
</code></pre>

<p>结合上面的create方法,同时我们知道每个方法都有自己的prototype,当我们在定义一个方法时,系统为我们指定了当前方法的prototype,同时指定了prototype里constructor的指向,具体如下:</p>

<pre><code class="Javascript">function YourConstructor() {
    // initialization
}
// JavaScript engine does this for you behind the scenes
YourConstructor.prototype = Object.create(Object.prototype, {
    constructor: {
        configurable: true,
        enumerable: true,
        value: YourConstructor,
        writable: true
    }
});
</code></pre>

<p>这其实是系统创建了一个Obejct.prototype的对象,然后让当前方法的prototype指向它.
下面我们来看一个复杂一些的例子:</p>

<pre><code class="Javascript">// overwrite prototype property
function Rectangle(length, width) {
    this.length = length;
    this.width = width
}
Rectangle.prototype.getArea = function() {
    return this.length * this.width;
};
Rectangle.prototype.toString = function() {
    return "[Rectangle " + this.length + "x" + this.width + "]";
};

function Square(size) {
    // constructor stealing, 调用父类的构造器
    Rectangle.call(this, size, size);
}
Square.prototype = new Rectangle();
Square.prototype.constructor = Square;
Square.prototype.toString = function() {
    return "[Square " + this.length + "x" + this.width + "]";
};
var rect = new Rectangle(5, 10);
var square = new Square(6);
console.log(rect.getArea());               // 50
console.log(square.getArea());             // 36

console.log(rect.toString());              // [Rectangle 5x10]
console.log(square.toString());            // [Square 6x6]

console.log(rect instanceof Rectangle);    // true
console.log(rect instanceof Object);       // true
console.log(square instanceof Square);     // true
console.log(square instanceof Rectangle);  // true
console.log(square instanceof Object);     // true
</code></pre>

<p>Square的对象同时是Square, Rectangle和Object的对像,下面这张图解释了原因:
<img src="/images/JS_inheritance/2.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript中的构造器(constructor)和原型(prototype)]]></title>
    <link href="http://qiusli.github.io/blog/2015/10/24/js-prototype/"/>
    <updated>2015-10-24T22:22:16-06:00</updated>
    <id>http://qiusli.github.io/blog/2015/10/24/js-prototype</id>
    <content type="html"><![CDATA[<h2>构造器</h2>

<p>JavaScript中的构造器其实就是方法/函数,我们新建一个方法,然后使用new去创建对象,可以说这个方法就是被创建的对象的原型.如果一个方法被作为对象的原型,约定俗成它应该大写字母开头.</p>

<pre><code class="Javascript">function Person(name) {
    this.name = name;
    this.sayName = function() {
        console.log(this.name);
    };
}
var person1 = new Person("Nick");
var person2 = new Person("Craig");
console.log(person1 instanceof  Person);    // true
console.log(person2 instanceof  Person);    // true
</code></pre>

<p>如果方法不接受参数,在使用new创建的时候可以省去括号</p>

<pre><code class="Javascript">function Person(){...}
var person1 = new Person;
</code></pre>

<p>每个新建的对象都有一个constructor property,它指向创建这个对象的方法.如果这个对象是使用Obejct literal或者new Object方法创建的,那么该对象的constructor指向object.</p>

<pre><code class="JavaScript">console.log(person1.constructor == Person); // true
console.log(person2.constructor == Person); // true
</code></pre>

<p>在使用构造器的时候前面要加上new关键字,表示被赋值的是一个对象,否则只是简单的方法调用.</p>

<pre><code class="Javascript">var person1 = Person("Nicholas");         // note: missing "new"console.log(person1 instanceof Person);   // falseconsole.log(typeof person1);              // "undefined"console.log(name);                        // "Nicholas"
</code></pre>

<h2>原型</h2>

<p>在创建对象时,我们有时会有这样一个疑虑:既然一些方法处理的事情是一样的,不过接受的参数不一样,我们为什么不能让许多对象共用这些方法呢?这就是prototype的由来.</p>

<p>每个对象都有一个prototype,prototype自身也是一个对象,它也有自己的property.几乎每一个方法都有自己的prototype property,所有通过该方法创建的对象都能访问该方法的propotype.我们可以把一个对象的原型想象成它的一个模板,这个对象从它的模板原型中得到一些property,然后基于这个继续扩展.</p>

<pre><code class="Javascript">
var book = {
    title: "the principle of object oriented javascript"
};
console.log("hasOwnProperty" in book);                            // true
console.log(book.hasOwnProperty("hasOwnProperty"));               // false
console.log(Object.prototype.hasOwnProperty("hasOwnProperty"));   // true
</code></pre>

<p>每一个对象在被创建后都有自己的[[Prototype]]property,它指向创建它的方法的prototype.</p>

<p> <img src="/images/JS_prototype/1.png"></p>

<p>当在试图访问一个对象上得某个property时,系统会先查看当前对象是否有这个own property,如果有则返回,否则继续查找它的[[Prototype]]指向的对象(即这个对象的原型)是否有这个property,有则返回否则返回undefined.prototype property不能被复写或者删除:</p>

<pre><code class="Javascript">var object = {};
console.log(object.toString());  // [object Object]
object.toString = function() {
    return "[object Custom]";
};
console.log(object.toString());  // [object Custom]
delete object.toString;
console.log(object.toString());  // [object Object]
delete object.toString;
console.log(object.toString());  // [object Object]
</code></pre>

<p>上面的代码首先打印原型的toString方法,然后试图修改这个prototype的方法,第二次成功打印出修改后的值.其实它并不是修改了prototype,而是创建了自己的一个own property,这个own property和prototype中的toString有相同的函数签名.然后我们试图删除prototype里的toString方法,这只是删除了自己定义的own property,最后一次是真正尝试删除prototype里的toString方法,但是并不成功,因为它不能在对象上删除.</p>

<p> <img src="/images/JS_prototype/2.png"></p>

<h3>创建prototype</h3>

<pre><code class="Javascript">function Car(brand) {
    this.brand = brand;
}
Car.prototype.sayBrand = function() {
    console.log(this.brand);
};
var car1 = new Car("BMW");
var car2 = new Car("Benz");
car1.sayBrand();                       // BMW
car2.sayBrand();                       // Benz
</code></pre>

<p>因为prototype里地property是所有对象共用的,这也许会产生一些潜在问题,即一个对象对prototype做出的改变会影响到另一个对象.</p>

<pre><code class="Javascript">console.log("5. ------");
Car.prototype.manufacureLocation = [];
car1.manufacureLocation.push("Chongqing");
car2.manufacureLocation.push("Beijing");
console.log(car1.manufacureLocation);      // [ 'Chongqing', 'Beijing' ]
console.log(car2.manufacureLocation);      // [ 'Chongqing', 'Beijing' ]
</code></pre>

<h3>同时创建多个prototype的property</h3>

<pre><code class="Javascript">function University(name) {
    this.name = name
}
University.prototype = {
    sayName: function() {
        console.log(this.name)
    },
    toString: function() {
        console.log("WUSTL")
    }
};
</code></pre>

<p>这样做很方便,但是它也有一个潜在的问题,即复写了方法自身的prototype.之前,在方法被创建时,它在prototype里有自己的constructor,它指向方法自身.但是在上面的University.prototype = {&hellip;}语句其实是使用Object literal方法对University方法的prototype重新赋值了,所以它的prototype里的constructor指向了新的对象的prototype,即object得prototype.</p>

<pre><code class="Javascript">var univ = new University("Washington University");
console.log(univ instanceof University);     // true
console.log(univ.constructor == University); // false
console.log(univ.constructor == Object);     // true
</code></pre>

<p>为了避免这种情况的出现,我们可以显式制定方法的constructor的指向:</p>

<pre><code class="Javascript">// solution to the above issue
function Computer(brand) {
    this.brand = brand
}
Computer.prototype = {
    constructor: Computer,
    sayBrand: function() {
        console.log("brand is " + this.brand)
    },
    statePrice: function() {
        console.log("price is quite high")
    }
};
var computer = new Computer("Lenovo");
console.log(computer instanceof Computer);     // true
console.log(computer.constructor == Computer); // true
</code></pre>

<pre><code class="Javascript">var computer1 = new Computer("Apple");
var computer2 = new Computer("Dell");
Computer.prototype.quote = function(quote) {
    console.log("quote of " + this.brand + " is " + quote)
};
computer1.quote("Think Different"); // quote of Apple is Think Different
computer2.quote("Whatever");        // quote of Dell is Whatever
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript中的对象]]></title>
    <link href="http://qiusli.github.io/blog/2015/10/24/js-object/"/>
    <updated>2015-10-24T13:32:50-06:00</updated>
    <id>http://qiusli.github.io/blog/2015/10/24/js-object</id>
    <content type="html"><![CDATA[<p>JavaScript中的对象较之于其他非动态语言的对象,最大的优势在于它能随时被改变.其他语言(例如Java)中一旦创建了class就不能再修改,而JavaScript创建对象只相当于创建了一个框架,后面随时可以往这个框架里添加东西.</p>

<!-- more -->


<h2>添加和设置property的原理:Put与Set</h2>

<p>当向对象中添加property时,其实是调用了对象的一个[[Put]]方法,这个方法存在于每个JavaScript对象中.当[[put]]被调用的时候,它创建的proterty是own property,即在当前环境下创建的property,不是从其他对象继承而来.对象中还有另一个[[Set]]方法,它在对象里property被重写的时候被系统调用.</p>

<h2>删除property</h2>

<p>对象在Javascript中存在的方式类似于键值对,增加property相当于add一个键值对,删除property相当于delete一个键值对.不能简单地通过把property设置为null来删除它,这样做的道理就是调用对象的[[Set]]方法来把键值对的值设置为null,但是键还在.正确的方法是使用delete方法.</p>

<pre><code class="Javascript">person.age = 27;
console.log("age" in person);  // true
delete  person.age;
console.log("age" in person);  // false
</code></pre>

<h2>检测property是否属于当前对象</h2>

<p>新手容易犯的一个错误是使用下面这种方法来检测property是否存在于一个对象:</p>

<pre><code class="JavaScript">var person = new Object();
person.name = "Kevin";
person.isCitizen = true;
if(person.name) {
    console.log(person.name); // kevin
}
</code></pre>

<p>Javascript中的if语句判断为真的条件是value为truthy即可,truthy的范围包括对象,非空字符串,非0,true等等.所以上面的if语句会被判断为真.if语句判断为假的条件是value为falsy,falsy的范围包括null,undefined,0,false,NaN或空字符串等.</p>

<p>正确的检测方法有2种,分别是in关键字和hasOwnproperty方法.前者覆盖的范围更广,所有从Object继承下来的方法都会被用来判断为当前对象的property,而后者更严格,只在当前环境下定义的对象property才被判断为真.</p>

<pre><code class="Javascript">person.sayName = function() {
    console.log("my name is " + this.name);
};
if("sayName" in person) {
    console.log("sayName is in person");       // sayName is in person
}
if("toString" in person) {
    console.log("toString is in person");      // toString is in person
}
if(person.hasOwnProperty("isCitizen")) {
    console.log("has own property isCitizen"); // has own property isCitizen
}
if(person.hasOwnProperty("toString")) {        // false
    console.log("has own property toString");
}
</code></pre>

<h2>property的类型</h2>

<p>Javascript对象property可以分为两种,分别是Data properties和Accessor properties,前者包括简单的数据条目键值对(name: &ldquo;Qiushi&rdquo;)和值为方法的键值对(sayName: function(){&hellip;}),无论是向对象中天剑简单数据条目或者值为方法的键值对,都调用的是对象的[[Put]]方法.Accessor properties是用来读取或者写入键值对的(类似于getter和setter).</p>

<pre><code class="Javascript">var qiushi = {
    // Javascript中的一种convention,以下划线开始的property被当做private的,但其实还是public的
    _age: 27,
    get age() {
        console.log("read age");
        return this._age;
    },
    set age(value) {
        console.log("set age");
        this._age = value;
    }
};
console.log(qiushi.age);  // read age 27
qiushi.age = 28;          // set age
</code></pre>

<h2>property的属性</h2>

<h3>遍历property(enumerable)</h3>

<p>可以使用for-in循环来遍历每个property:</p>

<pre><code class="Javascript">var usa = {
    state: 55,
    population: 320000000
};
for(var prop in usa) {
     // key
    console.log("property : " + prop);
    // value
    console.log("property value : " + usa[prop]);
}
</code></pre>

<p>对象中的每一个property默认都是能被遍历的,因为每个对象中的property有一个自己内部的叫做[[enumerable]]的属性,它定义当前property是否能被遍历.</p>

<pre><code class="Javascript">// state is enumerable : true
console.log("state is enumerable : " + usa.propertyIsEnumerable("state"));  
var keys = Object.keys(usa);
console.log("length" in keys); // true
// length is enumerable : false
console.log("length is enumerable : " + usa.propertyIsEnumerable("length"));
</code></pre>

<p>在使用literal或者constructor创建对象的时候,每一个property的[[enumerable]]属性默认为true,如果想创建不能被遍历的property,应该使用defineProperty方法:</p>

<pre><code class="Javascript">var person1 = {
    name: "Qiushi"
};
console.log(person1.propertyIsEnumerable("name"));  // true
Object.defineProperty(person1, "name", {
    enumerable: false
});
console.log(person1.propertyIsEnumerable("name"));  // false
</code></pre>

<h3>删除property(configurable)</h3>

<pre><code class="Javascript">delete person1.name;
console.log("name" in person1);  // true (意味着没被删除)
person1.name = "shawnee";
console.log(person1.name);       // shawnee (不能被删除但能被修改)
</code></pre>

<h3>修改property(writable)</h3>

<pre><code class="Javascript">Object.defineProperty(person1, "age", {
    value: 27,
    enumerable: true,
    configurable: true,
    writable: false
});
console.log(person1.age); // 27
person1.age = 99;
console.log(person1.age); // 27 (值没有被修改)
</code></pre>

<p>Accessor properties有[[Get]]和[[Set]]两种属性,所以在定义它时可以指定其属性的行为:</p>

<pre><code class="Javascript">var person1 = {    _name: "Nicholas"};Object.defineProperty(person1, "name", {    get: function() {        console.log("Reading name");        return this._name;    },    set: function(value) {        console.log("Setting name to %s", value);        this._name = value;    },    enumerable: true,    configurable: true});
</code></pre>

<h2>读取property的属性</h2>

<pre><code class="Javascript">Object.defineProperty(person1, "age", {
    value: 27,
    enumerable: true,
    configurable: true,
    writable: false
});

// retrieve property attributes
var descriptor = Object.getOwnPropertyDescriptor(person1, "age");
console.log(descriptor.enumerable);                               // true
console.log(descriptor.configurable);                             // true
console.log(descriptor.writable);                                 // false
</code></pre>

<h2>防止对象被修改的方法</h2>

<p>我们在一开始就提到Javascript中的对象可以在创建后被修改,但是在一些情况下我们想防止这种情况的发生,系统提供了3中方法.</p>

<h3>extensible</h3>

<p>顾名思义,它防止对象被extend,即不能添加新property到对象,但是能修改和删除已有property的内容.</p>

<pre><code class="Javascript">// prevent modification
console.log("is extensible : " + Object.isExtensible(person1)); // true
Object.preventExtensions(person1);
console.log("is extensible : " + Object.isExtensible(person1)); // false
</code></pre>

<h3>seal</h3>

<p>和extensible,但是不能删除已有的property.</p>

<pre><code class="Javascript">Object.seal(person1);
console.log("is sealed : " + Object.isSealed(person1));         // true
console.log("is extensible : " + Object.isExtensible(person1)); // false
person1.name = "Rashmi";
console.log(person1.name);                                      // Rashmi
delete person1.name;
console.log(person1.name);                                      // Rashmi (没有被删除)
</code></pre>

<h3>freeze</h3>

<p>和seal类似但更严厉,只能读取property</p>

<pre><code class="Javascript">var company = {
    name: "Goldman Sachs",
    size: "big",
    salary: "low"
};
console.log("is frozen " + Object.isFrozen(company)); // is frozen false
Object.freeze(company);
console.log("is frozen " + Object.isFrozen(company)); // is frozen true
company.name = "thoughtworks";
console.log(company.name);                            // Goldman Sachs
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript中的函数]]></title>
    <link href="http://qiusli.github.io/blog/2015/10/22/js-functions/"/>
    <updated>2015-10-22T19:21:12-06:00</updated>
    <id>http://qiusli.github.io/blog/2015/10/22/js-functions</id>
    <content type="html"><![CDATA[<p>JavaScript中的函数即对象,它也是以键值对的形式存在,但是它内部有一个internal
property叫做[[call]],它区分了其和对象的唯一不同,定义了自身的类型是函数,可以被执行调用,而对象只能被创建使用.同时如果使用typeof来查看类型,会返回function,internal
property从外部不可达.</p>

<!-- more -->


<h4>两种定义方法</h4>

<pre><code class="Javascript">// function declaration
function add(a, b) {
    return a + b;
}

// function expression
var k = function(a, b) {
    return a + b;
};
</code></pre>

<p>这两种定义方法基本类似,唯一的区别就是使用前者定义的方法可以在任何地方调用,因为系统总会把定义自动放到最前面(function
hoist),后者不会.</p>

<p>方法在Javascript中是一等公民,意味着你可以把它赋值给变量,把它加到方法里,作为参数传递,作为返回值等等.</p>

<pre><code class="Javascript">// pass function as parameter
var numbers = [3, 6, 2, 8, 4, 1, 7, 6, 8];
numbers.sort(function(first, second) {
    return first - second;
});
console.log(numbers);  // [ 1, 2, 3, 4, 6, 6, 7, 8, 8 ]
</code></pre>

<h4>参数</h4>

<p>函数可以接受零个或多个参数,函数接受的所有参数都被存在一个叫做arguments的变量中,可以在方法内部用其取出传递进来的参数.</p>

<pre><code class="Javascript">function sum() {
    var i = 0, sum = 0;
    for(; i &lt; arguments.length; i++) {
        sum += arguments[i];
    }
    return sum;
}
console.log(sum(1, 2, 3));     // 6
console.log(sum(1, 2, 3, 4));  // 10
</code></pre>

<p>上面的例子sum函数没有定义接受的参数个数,因为无论多少个,最终都是被存放在arguments变量里.如果定义了有限个的参数,多余的参数会被忽略.</p>

<pre><code class="Javascript">function refect(value) {
    return value;
}
console.log(refect("hi"));           // hi
console.log(refect("hi", 25));       // 25
console.log(refect("hi", 22, true)); // hi
</code></pre>

<p>由于函数在JavaScript中等同于对象,所有函数也可以有自己的属性(property).length就是其中的一个属性,它记录了函数接受的参数个数.</p>

<pre><code class="Javascript">function refect(value) {
    return value;
}
console.log(refect.length); // 1
</code></pre>

<h4>多态</h4>

<p>多态的区分是在函数签名,具体是方法名和参数的组合来区分.但是因为JavaScript函数能接受任意多的参数,所以导致不能够用参数来区分多个多态方法,所以JavaScript中没有多态一说.</p>

<pre><code class="Javascript">function sayMessage(message) {
    console.log(message);
}

function sayMessage() {
    console.log("Default Message");
}
sayMessage("Chelse");   // Default Message
</code></pre>

<p>在JavaScript中,如果你定义了多个同名方法,那么在你调用时,系统会取最后一个方法,前面的同名方法都被shadow掉了.因为函数等同于对象,系统在解析上面的代码时,其实是完成了下面的操作:</p>

<pre><code class="Javascript">var sayMessage = new Function("message", "console.log(message);");
// 变量指向了另一个对象
sayMessage = new Function("console.log(\"Default Message chongqing\");")
sayMessage("chongqing"); 
</code></pre>

<h4>关键字: this</h4>

<p>JavaScript代码中每一个scope里都有一个this关键字,代表了调用当前函数的那个对象.</p>

<pre><code class="Javascript">var person = {
    name: "Qiushi",
    sayName: function() {
        console.log(this.name);
    }
};
function sayNameForAll() {
    console.log(this.name);
}
var person1 = {
    name: "chelse",
    sayName: sayNameForAll
};
var person2 = {
    name: "ruth",
    sayName: sayNameForAll
};
// 这里的this代表person对象.
person.sayName();
// 这里的this代表person1对象.
person1.sayName();
// 这里的this代表person2对象.
person2.sayName();
name = "shawnee";
// 这里的this代表全局对象,即window,所以window.name只能是shawnee.
sayNameForAll();
</code></pre>

<p>上面的this指向都是隐式的,我们可以通过下面三种方法来显式制定this的指向.</p>

<h4>使用call</h4>

<pre><code class="Javascript">function speak(label) {
    console.log(label + this.language);
}
var p1 = {
    language: "chinese"
};
var p2 = {
    language: "spanish"
};
speak.call(p1, "我说 ");     // 我说 chinese
speak.call(p2, "I speak "); // I speak spanish
</code></pre>

<p>call方法的第一个参数指定this的指向,后面为参数.</p>

<h4>使用apply</h4>

<pre><code class="Javascript">speak.apply(p1, ["Kevin speaks "]); // Kevin speaks chinese
</code></pre>

<p>apply和call的唯一区别就是接受的第二个参数的类型,call接受单个参数,而apply接受一个数组,所以如果定义的方法接受多个参数,最好使用apply,反之则使用call.</p>

<h4>使用bind</h4>

<pre><code class="Javascript">function anotherSayName(label) {
    console.log(label + this.name);
}
var n1 = {
    name: "Ani"
};
var n2 = {
    name: "Rashmi"
};
var sayName1 = anotherSayName.bind(n1, "n1");
sayName1();                                           // n1Ani
var sayName2 = anotherSayName.bind(n2, "n2");
sayName2();                                       // n2Rashmi
n2.sayName = sayName1;
n2.sayName();                                     // n1Ani
</code></pre>

<p>值得注意的是最后输出为n1Ani而不是n2Rashmi,因为sayName1在最开始就指向了anotherSayName,this指向了n1,在重新赋值给n2的sayName时,其this指向不会被改变,所以输出n1Ani.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript中的类型]]></title>
    <link href="http://qiusli.github.io/blog/2015/10/21/js-types/"/>
    <updated>2015-10-21T20:34:58-06:00</updated>
    <id>http://qiusli.github.io/blog/2015/10/21/js-types</id>
    <content type="html"><![CDATA[<p>JavaScript一共有两种类型,非别为原始类型和引用类型.JavaScript使用一个叫做variable object的东西来记录创建的数据类型,如果新建数据为原始类型,则直接存储在variable object中,如果为引用类型,则用variable object来存放指向引用类型的指针.</p>

<!-- more -->


<h2>原始类型</h2>

<p>JavaScript一共有5种原始类型:
1. Boolean
2. Number
3. String
4. Null
5. Undefined
当把一个存储原始类型数据的变量赋值给另一个变量时,两个变量存储的值一样,但分别拥有的是各自的拷贝.</p>

<pre><code class="JavaScript">var color1 =  "red";
var color2 = color1;
color1 = "green";
console.log(color1); // green
console.log(color2); // red
</code></pre>

<h4>typeof 关键字</h4>

<p>用来判断当前原始类型的具体类型:</p>

<pre><code class="JavaScript">console.log(typeof 10);        // number
console.log(typeof "hello");   // string
console.log(typeof true);      // boolean
console.log(typeof null);      // object
console.log(typeof undefined); // undefined
</code></pre>

<h4>== 与 ===</h4>

<p>两者的作用基本一样,唯一的不同就是<code>==</code>在比较的时候会进行类型转换,而<code>===</code>则按原值比较.</p>

<pre><code class="JavaScript">console.log("5" == 5);           // true
console.log("5" === 5);          // false
console.log(true == "true");     // false
console.log(true === "true");    // false
console.log(null == null);       // true
console.log(null === null);      // true
console.log(null == undefined);  // true
console.log(null === undefined); // false
</code></pre>

<h2>引用类型</h2>

<p>引用类型即对象,它是由一组键值对组成,很像其他语言中的hash.键可以为string或者一般的literal,值为原始类型或者方法.创建对象一般有两种方法: 使用new和使用object literal.</p>

<pre><code class="JavaScript">1. 
var book = new Object();
book.name = "Head first Java"
book.year = 2014

2.
// literal
var book = {
    name: "javascript oo design",
    year: 2014
}
</code></pre>

<p>与原始类型的赋值不同的是,引用类型在赋值过程中不会在内存中再次拷贝指向数据,而是仅仅创建一个新的指针指向原来的引用.</p>

<pre><code class="JavaScript">var obj1 = new Object();
var obj2 = obj1;
obj1.myCustomProperty = "Qiushi";
console.log(obj2.myCustomProperty); // "Qiushi"
</code></pre>

<p>和Java类似,JavaScript也有垃圾回收机制,也即没有指针指向对象时,其被回收.</p>

<pre><code class="JavaScript">var obj = new Object();
obj = null;
</code></pre>

<h3>原始类型的包装</h3>

<p>原始类型中的String,Number和Boolean分别有其对应的包装类型,当系统检测到原始类型被读取并被当做对象使用时,系统会创建一个零时的原始类型的包装类,当包装类不再被使用的时候立即被系统回收.</p>

<pre><code class="JavaScript">var name = "Qiushi";
var firstChar = name.charAt(0);
console.log(firstChar);         // "Q"

在系统中被解释为:
var name = "Qiushi";
var tmp = new String(name);
var firstChar = tmp.charAt(0);
tmp = null;
console.log(firstChar);
</code></pre>

<p>例如如果我们按照下面这么做:</p>

<pre><code class="JavaScript">var name = "Nicholas";name.last = "Zakas";console.log(name.last);    // undefined

在系统中被解释为:
var name = "Nicholas";
var tmp = new Sring(name)tmp.last = "Zakas";
tmp = null                 // 零时变量被摧毁

var tmp = new String(name)console.log(name.last);   
tmp = null
</code></pre>

<p>再看下面这个例子:</p>

<pre><code class="JavaScript">var name = "Qiushi"
console.log(name instanceof String) // false
</code></pre>

<p>name在这里没有被当做对象使用(obj.xxx),所以没有零时对象创立,而原始类型不是其包装类的引用,所以会返回false.</p>
]]></content>
  </entry>
  
</feed>
