
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>暗淡蓝点  | 逆旅，行人</title>

	<meta name="author" content="李秋实"> 
	
	<meta name="description" content="JavaScript中的函数即对象,它也是以键值对的形式存在,但是它内部有一个internal property叫做[[call]],它区分了其和对象的唯一不同,定义了自身的类型是函数,可以被执行调用,而对象只能被创建使用.同时如果使用typeof来查看类型,会返回function, &hellip;"> <meta name="keywords" content="">

	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="逆旅，行人" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" rel="stylesheet" type="text/css">
	
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	
</head>



<body>
	<header id="header" class="inner"><h1>逆旅，行人</h1>
<nav id="main-nav"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/archives">Archive</a></li>
	<li><a href="/about">About</a></li>
</ul>
</nav>


</header>

	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/10/22/js-functions/">
		
			JavaScript中函数</a>
	</h2>
	<div class="entry-content">
		<p>JavaScript中的函数即对象,它也是以键值对的形式存在,但是它内部有一个internal property叫做[[call]],它区分了其和对象的唯一不同,定义了自身的类型是函数,可以被执行调用,而对象只能被创建使用.同时如果使用typeof来查看类型,会返回function,internal property从外部不可达.</p>


		
		<a href="/blog/2015/10/22/js-functions/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2015-10-22T19:21:12-06:00" pubdate data-updated="true">Oct 22nd, 2015</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/ke-ji/'>科技</a>

</div>


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/10/21/js-types/">
		
			JavaScript中的类型</a>
	</h2>
	<div class="entry-content">
		<p>JavaScript一共有两种类型,非别为原始类型和引用类型.JavaScript使用一个叫做variable object的东西来记录创建的数据类型,如果新建数据为原始类型,则直接存储在variable object中,如果为引用类型,则用variable object来存放指向引用类型的指针.</p>


		
		<a href="/blog/2015/10/21/js-types/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2015-10-21T20:34:58-06:00" pubdate data-updated="true">Oct 21st, 2015</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/ke-ji/'>科技</a>

</div>


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/10/17/event-and-delegate-in-c-number/">
		
			C#中的Delegate和Event</a>
	</h2>
	<div class="entry-content">
		<p>简单来说，deletegate就是一个指向function的指针，下面是一个其最简单的用法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">delegate</span> <span class="n">returntype</span> <span class="nf">delegateName</span><span class="p">(</span><span class="n">parameters</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>





		
		<a href="/blog/2015/10/17/event-and-delegate-in-c-number/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2015-10-17T15:06:20-06:00" pubdate data-updated="true">Oct 17th, 2015</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/ke-ji/'>科技</a>

</div>


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/10/17/how-to-blog-with-octopress/">
		
			如何使用Octopress写博客</a>
	</h2>
	<div class="entry-content">
		<p>具体的步骤是按照<a href="http://shengmingzhiqing.com/blog/setup-octopress-with-github-pages.html/">这个地址</a>来的。配置什么的都在里面，这里简单说说配置完成后到写博客的步骤</p>

<ol>
<li>rake new_post[&lsquo;blog title&rsquo;]创建新的文章</li>
<li>完成编辑后运行rake generate</li>
<li>然后rake preview在本地查看效果(<a href="http://localhost:4000/">http://localhost:4000/</a>)</li>
<li>rake deploy到github上</li>
<li>git add . 来把本地文件并入git管理</li>
<li>git commit －m ‘whatever’</li>
<li>git push origin source</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2015-10-17T03:12:48-06:00" pubdate data-updated="true">Oct 17th, 2015</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/za-ji/'>杂记</a>

</div>


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/10/15/spring-mvc/">
		
			Spring MVC学习笔记</a>
	</h2>
	<div class="entry-content">
		<p>学习Spring很长时间了，但是一直也没有认真地总结一次，总是陷入学习了忘记的怪圈（其实也不是怪圈，就是学习了没有总结）。 今天我就写一点东西来总结我的Spring MVC学习之旅。 这个得从我的Sponsor给我布置的家庭作业讲起，在这里面我学会了很多Spring的知识。</p>

<p>可以假设Spring是一个大的容器，里面放着各种各样的网页、文件等以供一个个的request访问。所以，我想从web.xml的配置说起。</p>


		
		<a href="/blog/2015/10/15/spring-mvc/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2015-10-15T16:55:12-06:00" pubdate data-updated="true">Oct 15th, 2015</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/technology/'>technology</a>

</div>


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/05/31/git-3/">
		
			Git 3 (Branching)</a>
	</h2>
	<div class="entry-content">
		<h2>What is Git Branch</h2>

<p><code>分支的好处</code>: 它允许在不干扰主分支的情况下,从主分支里分离出一条小的分支,在里面进行开发,然后再把修改合并到主分支里.</p>

<p><code>什么是分支</code>: 在Git下提交时,Git会保存每一次提交的快照,并且会保存一个指向祖先的指针.第一次提交时没有祖先,普通提交有一个祖先,由两个或多个分支合并而成的提交则有多个祖先.</p>


		
		<a href="/blog/2014/05/31/git-3/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-05-31T19:26:00-06:00" pubdate data-updated="true">May 31st, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/05/23/tg-day-3/">
		
			TG Day 3</a>
	</h2>
	<div class="entry-content">
		<p>唉,今天过得不爽,因为效率太低了.睡少了,晚上大概只睡了6个小时,导致中午在听Brian讲课的时候都反应不过来.下午想把RabbitMQ看完,但是效率也不高,拖拖拉拉也没看出个明白.</p>

<p>睡眠太重要啦!!!!</p>


		
		<a href="/blog/2014/05/23/tg-day-3/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-05-23T00:17:00-06:00" pubdate data-updated="true">May 23rd, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/05/21/tg-day-2/">
		
			TG Day 2</a>
	</h2>
	<div class="entry-content">
		<p>首先检查昨天提出的改进是否做好了,</p>

<ul>
<li>多和同事交流: 这个做得还行,比第一天好多了,主动去找了Kate和Pablo pair,熟悉了项目的开发流程.</li>
<li>专心做事:这个做得也还可以,在做事的时候没有太多的分心,只是Stemle在讲解business的时候由于前晚没睡好,导致分心了没有听进去.</li>
<li>搞清楚terminologies,搞懂项目架构:前者感觉做到80%,后者没有太多的时间搞.项目架构是个大活,得一天一天搞.</li>
</ul>



		
		<a href="/blog/2014/05/21/tg-day-2/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-05-21T23:46:00-06:00" pubdate data-updated="true">May 21st, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/05/20/tg-day-1/">
		
			TG Day 1</a>
	</h2>
	<div class="entry-content">
		<p>今天是暑期实习的第一天,平时都睡太晚了,昨晚一直睡不着,幸好今天事也不多,没有太多地表现出来.</p>

<p>上午平平淡淡地被溜了一圈分别各自介绍,拿到了电脑,填写了一堆文件.之后带我的人就开始给我灌输一些项目里面用到的知识,东西太多,有点overwhelmed的感觉.但好的是我吸取了在TW的教训,干什么事都拿个小本子遇到重点就记下来,以后也可以照着复习.</p>


		
		<a href="/blog/2014/05/20/tg-day-1/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-05-20T23:15:00-06:00" pubdate data-updated="true">May 20th, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/05/18/linux2/">
		
			Linux 2</a>
	</h2>
	<div class="entry-content">
		<h2>Manipulating files and directories</h2>

<p>在操作文件的时候,通常都需要首先根据一定的条件来选择想要的文件(比如说以数字结尾的文件或者扩展名为xls的文件).这时我们需要使用通配符,它使用一定的规则帮助快速找到想要的文件.</p>


		
		<a href="/blog/2014/05/18/linux2/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-05-18T12:32:00-06:00" pubdate data-updated="true">May 18th, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/05/18/linux1/">
		
			Linux 1</a>
	</h2>
	<div class="entry-content">
		<h1>INTRODUCTION</h1>

<h2>What is the Shell</h2>

<p>Shell是一个应用程序,它接受用户的键盘输入,然后把这些输入传入到操作系统并返回结果.</p>

<h2>What is the Bash</h2>

<p>几乎所有的Linux Distribution都提供一个叫做<code>bash</code>的shell应用程序,bash是GNU项目的产物.<code>bash</code>的全称是<code>Bourne Again Shell</code>,从名称上就能看出它是一般Shell(<code>sh</code>)的加强版本.最早期的Shell是由Steve Bourne编写.</p>


		
		<a href="/blog/2014/05/18/linux1/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-05-18T11:36:00-06:00" pubdate data-updated="true">May 18th, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/05/09/ios-programming-8-uitableview-and-uitableviewcontroller/">
		
			iOS Programming 8 (UITableView &amp; UITableViewController)</a>
	</h2>
	<div class="entry-content">
		<p><code>UITableView</code>在iOS中是一个很重要的概念,它会把数据像列表一样显示在屏幕上.首先需要介绍几个概念:</p>

<ul>
<li><code>UITableView</code>: 它是一个view,用于在屏幕上显示数据.它会向其对应的<code>dataSource</code>询问应该显示什么数据,然后再显示.对应的<code>dataShource</code>需要遵循<code>UITableViewDataSource</code>Protocol.</li>
<li><code>UITableView</code>同时需要一个delegate,用来处理在<code>UITableView</code>上传出来的事件.这个delegate需要遵循<code>UITableViewDelegate</code> Protocol.</li>
<li><code>UITableView</code>需要一个view controller来与之协作.</li>
</ul>



		
		<a href="/blog/2014/05/09/ios-programming-8-uitableview-and-uitableviewcontroller/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-05-09T12:20:00-06:00" pubdate data-updated="true">May 9th, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/05/07/git-2/">
		
			Git 2 (Basics)</a>
	</h2>
	<div class="entry-content">
		<h2>Initialize a repository</h2>

<p>Git的操作都需要在一个由Git管理的文件下进行,有两种方式使文件被git管理:</p>

<ul>
<li>在文件夹下面执行 <code>git init</code></li>
<li><code>git clone</code>一个现成的git文件夹然后在里面操作</li>
</ul>


<p>如果要在server上面获取现有的项目,可以执行<code>git clone</code>.和SVN不同的是这里的关键词是clone,而SVN里面是checkout,这是因为git是clone整个项目,相当于把server上所以东西都搬下来,而git只是checkout最新的版本.</p>


		
		<a href="/blog/2014/05/07/git-2/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-05-07T21:35:00-06:00" pubdate data-updated="true">May 7th, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/05/07/git-1/">
		
			Git 1 (Basic Concept)</a>
	</h2>
	<div class="entry-content">
		<p>原来学过Git,但学得不扎实,而且学过之后也没怎么用,导致每次要用的时候都得重新学一遍.现在再次学习,把学到的记录下来,以后忘了复习起来也方便.</p>

<h2>Centralized Version Control vs Distributed Version Control</h2>

<p>集中式的版本管理把所有的文件放到一个server上面,所有的其他电脑都从这个server上面得到最新的代码.这样的坏处显而易见,如果server宕机了,其他一切有关的活动都得终止.</p>


		
		<a href="/blog/2014/05/07/git-1/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-05-07T00:27:00-06:00" pubdate data-updated="true">May 7th, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/05/06/ios-programming-7-delegation-and-text-input/">
		
			iOS Programming 7 (Delegation and Text Input)</a>
	</h2>
	<div class="entry-content">
		<h2>UIResponder</h2>

<p>这一章主要讲解了iOS中的delegation.为了使这个概念更加清楚,我们通过一个例子来讲解.在上一章代码的基础上,我们在UITabBarController的第一个viewcontroller上加一个UITextField,这个textfield允许用户输入. 在创建完UITextField之后,我们把它加到viewcontroller的view中去:</p>


		
		<a href="/blog/2014/05/06/ios-programming-7-delegation-and-text-input/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-05-06T21:01:00-06:00" pubdate data-updated="true">May 6th, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/05/06/ios-programming-6-2-uitabviewcontrollers/">
		
			iOS Programming 6-2(UITabBarController)</a>
	</h2>
	<div class="entry-content">
		<p>我们在上一章中讲到了如何使用viewcontroller,这里我讲讲解一种技术,它可以管理多个viewcontroller,并在这些viewcontroller之间切换,这项技术叫做UITabBarController.</p>

<p>在使用这项技术后,效果如下.我们可以看到在屏幕的下端有两个按钮可以互相切换,他们分别对应一个viewcontroller:</p>


		
		<a href="/blog/2014/05/06/ios-programming-6-2-uitabviewcontrollers/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-05-06T15:57:00-06:00" pubdate data-updated="true">May 6th, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/04/12/google-analytics/">
		
			Google Analytics</a>
	</h2>
	<div class="entry-content">
		<p>最近在iOS的final project中用到了google analytics来分析用户行为,自己也做了一些research,今天就把它记录在这里.</p>

<p>在介绍之前先说说这个iOS app的概况,他是一个时间记录仪,有显示当前时间(ClockViewController)和stopwatch的功能(StopWatchViewController),可以在app下面的tab切换.我今天要做的是首先为显示时间的view加一个track,然后再到stopwatch里面加两个track用户点击按钮的功能.</p>


		
		<a href="/blog/2014/04/12/google-analytics/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-04-12T20:52:00-06:00" pubdate data-updated="true">Apr 12th, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/04/06/ios-6/">
		
			iOS Programming 6-1(View Controllers)</a>
	</h2>
	<div class="entry-content">
		<p>前面讲过了view和View hierachy,为了让view在window上显示,我们都是直接把一个view加到应用的window里面去,今天要讲的东西比view更高级一层,他叫view controller.他的职责是创建view,响应view的事件,管理view的层级关系,把view加到window里.</p>

<p>我会结合一个实际的应用来阐述view controller,这个应用最后出来的效果会想下面这样:</p>


		
		<a href="/blog/2014/04/06/ios-6/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-04-06T19:55:00-06:00" pubdate data-updated="true">Apr 6th, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/04/04/ios-programming-5/">
		
			iOS Programming 5(Redrawing and UIScrollView)</a>
	</h2>
	<div class="entry-content">
		<p>在上一篇博客中,我们创建了一个画同心圆的app,这篇博客将继续在那上面扩展,当用户在屏幕上点击的时候同心圆会改变颜色.此外,还将在app里面加上UIScrollView,让用户通过scroll的方式浏览比屏幕本身大的view.</p>

<h2>改变同心圆颜色</h2>

<p>既然是通过点击来改变同心圆的颜色,那么我们肯定会想到用touch event来实现,在用户touch之后需要改变颜色,我们可以通过创建一个公有变量,然后在touch方法里改变他的颜色. 我们现在项目的格局如下:</p>


		
		<a href="/blog/2014/04/04/ios-programming-5/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-04-04T13:08:00-06:00" pubdate data-updated="true">Apr 4th, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/04/03/backtrack/">
		
			使用递归计算的回溯法</a>
	</h2>
	<div class="entry-content">
		<p>谈到这个方法的初衷本来是想在iOS项目中使用,因为当时叫设计一种方法来摆放battleship,如果在当前位置不能摆放可以回溯到上一个地点再试,最后还是放弃了,因为用不了这么复杂的方法. 不过既然学习了,并且花了这么多时间来编码,就应该记录下来,以后可能还会用上,就不必又从开头来学了.</p>

<h3>什么是回溯法</h3>

<p>回溯法就是先在一条路上走到黑,发现还没达到目的,然后就退回到上一步,然后把另一个发展方向试一遍,直到找到一条通路为止.</p>


		
		<a href="/blog/2014/04/03/backtrack/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-04-03T21:59:00-06:00" pubdate data-updated="true">Apr 3rd, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/03/09/ios-4/">
		
			iOS Programming 4(Views and the View Hierarchy)</a>
	</h2>
	<div class="entry-content">
		<h3>View Basics</h3>

<p>在iOS中，每一个应用都有一个UIWindow的对象，他是应用中所有view的容器(container)，其实UIWindow自己也只是一个view，只不过他的职责不是显示view，而是作为容器存放view。当应用启动的时候，这个对象就被创建，我们可以往这个容器里面添加其他的view。那么什么是view呢？他是在屏幕上被显示的元素，例如button。每一个view都是UIView或UIView的子类的一个实例，每一个view都有一个对应的layer，view在其对应的那样儿上显示自己，我们可以想象成每个view都自带了一块画板，在画板上作画然后贴到最大的canvas(UIWindow)上去。view还能handle屏幕上的一些事件，例如button能handle touch事件。view之间存在层级关系(hierarchy),一个view可以包含另一个view，我们可以把其中的关系想象成一棵树，根结点就是UIWindow。</p>


		
		<a href="/blog/2014/03/09/ios-4/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-03-09T19:08:00-06:00" pubdate data-updated="true">Mar 9th, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/03/08/ios-3/">
		
			iOS Programming 3(Managing Memory Wih ARC)</a>
	</h2>
	<div class="entry-content">
		<h3>栈和堆</h3>

<p>当一个方法被执行的时候，系统会从栈中分配出一定的内存让代码在其中运行，这一块专门分配出来的内存叫做frame，每一个方法都有一个frame。当方法从main方法中开始执行的时候，main方法的frame被放到了栈上，然后如果在main方法中有其他方法的调用，就会有不断的frame被加到栈上，下图就是在一个栈上不断调用和结束调用方法的对应的frame结构：</p>


		
		<a href="/blog/2014/03/08/ios-3/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-03-08T18:54:00-07:00" pubdate data-updated="true">Mar 8th, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/03/07/ios-programming-2/">
		
			iOS Programming 2(objective-c)</a>
	</h2>
	<div class="entry-content">
		<p>Objective-c中的方法调用其实是一种消息传送的机制，例如下面这段代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">[</span><span class="n">partyInstance</span> <span class="nl">addAttendee</span><span class="p">:</span><span class="n">somePerson</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>他表达的意思是发送addAttendee:消息给partyInstance对象，然后这个对象再去调用他的类中的addAttendee方法，somePerson在这里是参数。在运行时，消息被发送到对象，然后对象会向创建自己的那个类寻求帮助，并告诉这个类去运行消息中指定的方法(e.g. addAttendee)(这里需要注意的是，一切都是发生在运行时，而不是一些其他语言在编译时进行检查)。那么一个对象又是怎么知道自己属于哪个类呢？其实每个对象都有一个叫做'isa'的instance variable，当这个对象被创建的时候，这个isa就自动被初始化为指向创建他的那个类。这个instance variable叫做'isa'是有道理的，因为他是创建他的类的一个实例。他们的关系如下：</p>


		
		<a href="/blog/2014/03/07/ios-programming-2/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-03-07T18:36:00-07:00" pubdate data-updated="true">Mar 7th, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/03/06/ios-programming-1/">
		
			iOS Programming 1(A Simple iOS Application)</a>
	</h2>
	<div class="entry-content">
		<p>最近在学习iOS开发，虽然课上也有讲，但是还是不如自己看书学得更实在，今天就从最基础的iOS开发说起。值得注意的是，我在这类博客里所讲到的内容，完全是按照iOS Programming: The Big Nerd Ranch Guide第四版里面来的。</p>


		
		<a href="/blog/2014/03/06/ios-programming-1/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2014-03-06T14:07:00-07:00" pubdate data-updated="true">Mar 6th, 2014</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/08/23/quick-sort/">
		
			快速排序(Quicksort)</a>
	</h2>
	<div class="entry-content">
		<p>Quick Sort即快速排序，它是对归并排序的一种补充，采用的也是分治策略。基本思想是在整个数组中选择第一个数作为一个基准，然后分别从第二个数向后和最后一个数向前开始扫描。如果在向后扫描的过程中如果遇到比基准大的数字(我们这里假设默认为升序排列)，同时在从后向前扫描的过程中遇到比基准小的数字，那么这两个数字就交换。这个过程一直持续下去直到从左扫描的下标大于从右开始扫描的下标作为结束。最后，把基准和右边下标指向的数交换，这样基准左边的数字都小于该基准，基准右边的数字都大于它。不断地递归这个过程就是快速排序。我们可以看看下面这个图帮助理解：</p>


		
		<a href="/blog/2013/08/23/quick-sort/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-08-23T21:57:00-06:00" pubdate data-updated="true">Aug 23rd, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/08/23/merge-sort/">
		
			归并排序(Mergesort)</a>
	</h2>
	<div class="entry-content">
		<p>Merge sort即归并排序，它的中心思想是分而治之(divide and conquer)，即将一个原来很大的待排序数列分成若干个小的数列然后分别对他们进行排序，最后把小的排好序的数列合并起来。这个过程可以分为三个步骤：</p>

<p>第一, 分解: 把待排序的 n 个元素的序列分解成两个子序列, 每个子序列包括 n/2 个元素.</p>

<p>第二, 治理: 对每个子序列分别调用归并排序MergeSort, 进行递归操作。</p>

<p>第三, 合并: 合并两个排好序的子序列,生成排序结果。</p>

<p>在我看来，归并排序中最重要的还是‘合并’，因为在多次递归分解之后，剩下的大小为2的数组都是通过‘合并’过程达到排序的目的。合并的过程很简单，从下面这张图就能大概看出来：</p>


		
		<a href="/blog/2013/08/23/merge-sort/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-08-23T08:51:00-06:00" pubdate data-updated="true">Aug 23rd, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/08/13/selection-insertion-and-shellsort/">
		
			选择排序(Selection sort)插入排序(Insertion sort)与希尔排序(Shellsort)</a>
	</h2>
	<div class="entry-content">
		<p>一、选择排序</p>

<p>选择排序之所以被称为选择排序是因为在每一次的迭代过程中，总是‘选择’最小的一个元素到数组的最左边。下面是一个选择排序的实例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">[</span><span class="n">min</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">min</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">exchange</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">min</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>



		
		<a href="/blog/2013/08/13/selection-insertion-and-shellsort/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-08-13T00:03:00-06:00" pubdate data-updated="true">Aug 13th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/08/10/java-reorder/">
		
			理解Java中的重排序</a>
	</h2>
	<div class="entry-content">
		<p>重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：编译期重排序和运行期重排序，分别对应编译时和运行时环境。</p>

<p>在并发程序中，程序员会特别关注不同进程或线程之间的数据同步，特别是多个线程同时修改同一变量时，必须采取可靠的同步或其它措施保障数据被正确地修改，这里的一条重要原则是：不要假设指令执行的顺序，你无法预知不同线程之间的指令会以何种顺序执行。</p>

<p>但是在单线程程序中，通常我们容易假设指令是顺序执行的，否则可以想象程序会发生什么可怕的变化。理想的模型是：各种指令执行的顺序是唯一且有序的，这个顺序就是它们被编写在代码中的顺序，与处理器或其它因素无关，这种模型被称作顺序一致性模型，也是基于冯·诺依曼体系的模型。当然，这种假设本身是合理的，在实践中也鲜有异常发生，但事实上，没有哪个现代多处理器架构会采用这种模型，因为它是在是太低效了。而在编译优化和CPU流水线中，几乎都涉及到指令重排序。</p>


		
		<a href="/blog/2013/08/10/java-reorder/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-08-10T13:08:00-06:00" pubdate data-updated="true">Aug 10th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/08/09/java-equals-hashcode/">
		
			在java中复写equals和hashCode</a>
	</h2>
	<div class="entry-content">
		<p>首先我们必须得知道什么是hash code。总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。你知道它们的区别吗？前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。于是，Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。如果详细讲解哈希算法，那需要更多的文章篇幅，我在这里就不介绍了。初学者可以这样理解，hashCode方法实际上返回的就是对象存储的物理地址（实际可能并不是）。这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。所以，Java对于eqauls方法和hashCode方法是这样规定的：1、如果两个对象相同，那么它们的hashCode值一定要相同；2、如果两个对象的hashCode相同，它们并不一定相同。</p>


		
		<a href="/blog/2013/08/09/java-equals-hashcode/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-08-09T22:50:00-06:00" pubdate data-updated="true">Aug 9th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/08/08/java-immutable/">
		
			如何在Java中创建Immutable的类</a>
	</h2>
	<div class="entry-content">
		<p>首先，我们需要明白什么是Immutable的类。顾名思义，就是在对象创建后，它的状态不能改变。你首先也许会想到final这个关键字，因为它会使被修饰者要么不能被继承(修饰类)，要么不能被重新赋值(修饰字段)。下面我们来看一个简单的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">final</span> <span class="kd">class</span> <span class="nc">ImmutableClass_1</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="nf">getI</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">double</span> <span class="nf">getJ</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">j</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>



		
		<a href="/blog/2013/08/08/java-immutable/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-08-08T21:30:00-06:00" pubdate data-updated="true">Aug 8th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/27/java-annotation/">
		
			Java Annotation学习笔记</a>
	</h2>
	<div class="entry-content">
		<ol>
<li>Annotation是什么
Annotation是类，方法或字段的一种注解或元数据，当程序被JVM编译的时候，annotation会和类编译在一起，作为一种元数据去描述被修饰的数据</li>
<li>Annotation的定义</li>
</ol>



		
		<a href="/blog/2013/07/27/java-annotation/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-27T20:23:00-06:00" pubdate data-updated="true">Jul 27th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/27/comparator/">
		
			Java中Comparable和Comparator实现对象比较</a>
	</h2>
	<div class="entry-content">
		<p>当需要排序的集合或数组不是单纯的数字型时，通常可以使用Comparator或Comparable，以简单的方式实现对象排序或自定义排序。下面通过两个例子分别用Comparable和Comparator实现对User对象中年龄排序。</p>


		
		<a href="/blog/2013/07/27/comparator/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-27T20:20:00-06:00" pubdate data-updated="true">Jul 27th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/27/wiser/">
		
			使用Wiser测试邮件发送</a>
	</h2>
	<div class="entry-content">
		<p>最近在做一个小项目，里面有发送邮件这一功能，本文主要是讲如何通过Spring发送邮件，已经一个邮件测试框架 &mdash; wiser的介绍。</p>

<p>如何使用Spring发送邮件
首先主要用到的一个类是JavaMailSenderImpl，它位于Spring的org.springframework.mail.
javamail包中，主要是用来发送邮件的。为了发送邮件，需要提供给它一系列的参数。这些参数我都配置在了resources包下的一个xml文件中</p>


		
		<a href="/blog/2013/07/27/wiser/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-27T20:14:00-06:00" pubdate data-updated="true">Jul 27th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/18/proxy-pattern/">
		
			深入浅出设计模式之代理模式(Proxy Pattern)</a>
	</h2>
	<div class="entry-content">
		<p>所谓代理，即控制盒管理对目标对象访问的一个中间层。它代表一个真实的对象，并呈现给外界一个假象&ndash;它就是真正的对象，但其实他的一切动作都是调用真实对象来完成的。</p>

<p>一、远程代理</p>

<p>代理模式有很多种，首先我们来讲远程代理。如果我有两个类ClassA和ClassB,它们分别位于不同的机器上(意味着它们在不同的JVM的堆中)。如果ClassA想要调用ClassB中的方法，这时就需要一个远程代理。远程代理就好像是“远程对象的本地代表”，它是一个可以由本地方法调用的对象，其行为会转发到远程对象中。</p>


		
		<a href="/blog/2013/07/18/proxy-pattern/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-18T18:09:00-06:00" pubdate data-updated="true">Jul 18th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/16/state-pattern/">
		
			深入浅出设计模式之状态模式(State Pattern)</a>
	</h2>
	<div class="entry-content">
		<p>在现实生活中，常常遇到许多与状态相关的问题，一些状态因为一些行为的触发转移到下一个状态。就拿一个糖果机为例子吧，糖果机有四种状态：没有25分钱、有25分钱、售出糖果和糖果售罄。由不同的触发条件到达另一种状态.例如如果没有25分钱，投入25分钱，会达到有25分钱的状态，其他状态如下图所示：</p>

<p><img src="/images/state_pattern-1.png"></p>


		
		<a href="/blog/2013/07/16/state-pattern/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-16T22:39:00-06:00" pubdate data-updated="true">Jul 16th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/16/iterator-pattern/">
		
			深入浅出设计模式之迭代器模式(Iterator Pattern)和组合模式(Composite Pattern)</a>
	</h2>
	<div class="entry-content">
		<p>一、迭代器模式</p>

<p>迭代器模式应用了封装的原理，封装了可迭代组件的具体实现，游走于聚合内每一个元素，而又不暴露内部的表示。举个例子吧，有两家餐馆，它们现在合并了，这样提供的菜品就是原来的2倍。但是餐馆A使用数组来存储菜品，而餐馆B用列表来存储。如果想看所有的菜品，还得通过两种方式便利得到全部内容，这样很不方便，于是就想到了通过迭代器模式封装它们。</p>


		
		<a href="/blog/2013/07/16/iterator-pattern/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-16T16:52:00-06:00" pubdate data-updated="true">Jul 16th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/14/template-method/">
		
			深入浅出设计模式之模板方法模式(Template Method)</a>
	</h2>
	<div class="entry-content">
		<p>模板方法模式，顾名思义，必定有一个类提供了一个模板，完成一件工作。其他类使用这个模板完成自己的工作，但是由于各个类之间所要完成的工作之间并不完全一致，所有在模板方法类中会可以留下一些抽象方法供其他类自己来实现，这样通过模板方法达到的效果就产生了区别。例如，如果我要泡一杯咖啡，需要的步骤是</p>


		
		<a href="/blog/2013/07/14/template-method/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-14T14:41:00-06:00" pubdate data-updated="true">Jul 14th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/14/adaptor-pattern/">
		
			深入浅出设计模式之适配器模式(Adaptor Pattern)与外观模式(Facade Pattern)</a>
	</h2>
	<div class="entry-content">
		<p>一、适配器模式
我们每个人在生活中都经历过这样的事，手中的电子产品和插座要求的接口类型不相符，比如插座要求的是三孔，而自己的插头是两孔，这个时候就需要一个电源适配器插在原先的插座上，然后再适配器的另一端暴露一个两孔的插孔供我们使用。对于客户来说，不管原来插座式几孔的，他只在乎自己能用的是两孔的就行了，其它的都交给了适配器去做。</p>


		
		<a href="/blog/2013/07/14/adaptor-pattern/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-14T10:31:00-06:00" pubdate data-updated="true">Jul 14th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/13/command-pattern/">
		
			深入浅出设计模式之命令模式(Command Pattern)</a>
	</h2>
	<div class="entry-content">
		<p>命令模式，顾名思义，一定是有大哥发命令，一定有小弟在执行这个命令，理解了这个，命令模式就不难了。命令模式里面分为三种角色，发送者、命令对象和接受执行者。比如说有一个遥控板，它可以控制室内的灯光，那么遥控板在这里就是一个发送者，它发送命令给命令对象，命令对象接到命令后就只管执行。下面来看这个命令模式的实现吧：</p>


		
		<a href="/blog/2013/07/13/command-pattern/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-13T19:12:00-06:00" pubdate data-updated="true">Jul 13th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/13/singleton-pattern/">
		
			深入浅出设计模式之单件模式(Singleton Pattern)</a>
	</h2>
	<div class="entry-content">
		<p>单件模式是最简单的一种设计模式，因为从头到尾都只涉及到一个类。单件模式想要达到的目的是在程序运行的过程中只创建一个类的对象，在很多场合这都很有用，比如注册表程序，你不会想要很多对象来，因为那样会造成混乱且很占内存，一个对象足矣。那么应该怎么应用单件模式呢？例子很简单，代码如下：</p>


		
		<a href="/blog/2013/07/13/singleton-pattern/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-13T15:21:00-06:00" pubdate data-updated="true">Jul 13th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/13/factory-pattern/">
		
			深入浅出设计模式之工厂模式(Factory Method Pattern)</a>
	</h2>
	<div class="entry-content">
		<p>工厂模式算是设计模式中用到的最多的一类了，对于它最直观的描述就是：父类定义一个创建对象的接口，由子类决定需要创建什么对象，这样让类把实例化推迟到了子类。下面来举个例子来阐述吧。</p>

<p>有一个披萨店，可以做各种各样的披萨，但位于不同地方的分店里的披萨味道会有些不同。如果利用工厂模式，就是：</p>


		
		<a href="/blog/2013/07/13/factory-pattern/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-13T14:01:00-06:00" pubdate data-updated="true">Jul 13th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/12/decorator-pattern/">
		
			深入浅出设计模式之装饰器模式(Decorator Pattern)</a>
	</h2>
	<div class="entry-content">
		<p>今天该讲第三种设计模式 &ndash; 装饰器模式。同样，从名字就可以看出这种模式必定有一个基础组件，用来被修饰，也会有至少一个装饰器来修饰基础组件。同时要求被装饰器修饰过的组件对外界来说还是一个组件，只不过在被修饰之后多出了一些以前没有的功能。装饰器模式可以看做下图：</p>


		
		<a href="/blog/2013/07/12/decorator-pattern/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-12T14:53:00-06:00" pubdate data-updated="true">Jul 12th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/11/observer-pattern/">
		
			深入浅出设计模式之观察者模式(Observer Pattern)</a>
	</h2>
	<div class="entry-content">
		<p>观察者模式，顾名思义，这个模式中必定有观察者和被观察者。打一个形象的比喻，一些在证券交易市场的股民眼巴巴地看着自己买的股票所代表的公司能放些风声出来，这样自己就可以更好地把握这个消息做出买或卖的决定。而上市公司为了加强广大股民的信心，鼓励大家增持股票也会不断地放出例如公司的新项目马上出来了，大家赶紧买啊这些消息。我们暂且不论消息的真假，但这确实一个非常贴切的例子。</p>


		
		<a href="/blog/2013/07/11/observer-pattern/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-11T21:39:00-06:00" pubdate data-updated="true">Jul 11th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/11/strategy-pattern/">
		
			深入浅出设计模式之策略模式(Strategy Pattern)</a>
	</h2>
	<div class="entry-content">
		<p>今天开始阅读Head First设计模式，老早就听说这是一本经典书籍，但是这类华丽的辞藻确实听过太多，每每在阅读的时候发现自己也许期望太高了或者自己的水平不足，并没有带给自己耳目一新的感觉。但是今天在阅读这本书的时候，终于找到了一种久违的兴奋感，而它更来自于对书中内容的由浅入深的理解和阅读的乐趣。例如，在第一章讲解策略模式的时候，在读到书的最后一页之前，我并不知道自己学习的是哪种模式，所以在学习的过程中
我能完全静下心来理解纯粹的内容，而不是一边试图去记住“策略模式”这四个字，一边去看“策略”应用在哪里，而在这个过程中往往偏离了书本想要表达的内容，及作者期望读者走的学习道路，致使书本的作用大大降低。从引导读者这一点上来说，Head First设计模式这本书做得非常好！</p>


		
		<a href="/blog/2013/07/11/strategy-pattern/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-11T00:02:00-06:00" pubdate data-updated="true">Jul 11th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/09/tail-recursion/">
		
			一般递归与尾递归(Tail Recursion)</a>
	</h2>
	<div class="entry-content">
		<p>最近在读一篇文章的时候无意间接触到了尾递归，感觉他比一般的递归好用，有点意思，顾将之记录下来。</p>

<p>首先需要了解的是到底什么是尾递归？
这个问题其实很简单，顾名思义，尾递归就是在一个方法的尾部、且在函数返回前的最后一步调用函数本身。为了更好地理解，还是上代码吧(以著名的斐波拉契为例)：</p>


		
		<a href="/blog/2013/07/09/tail-recursion/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-09T21:58:00-06:00" pubdate data-updated="true">Jul 9th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/09/deep-copy-and-shallow-copy/">
		
			Java中对象的浅拷贝与深拷贝</a>
	</h2>
	<div class="entry-content">
		<p>Java中的拷贝方式分为深拷贝和浅拷贝。简单来说，深拷贝就是把一个对象中的所有值，如果被拷贝对象中有对其他对象的引用，那么这个引用指向的对象本身会被重新创建。浅拷贝和深拷贝类似，但是如果被拷贝对象中有对其他对象的引用，只是这个引用会被拷贝，而不是这个被引用的对象。</p>

<p>说起来有点绕口，那么我们就看看下面的图解吧：</p>

<p><img src="/images/deep_shallow_copy-1.png"></p>

<p>shallow copy:</p>

<p><img src="/images/deep_shallow_copy-2.png"></p>

<p>deep copy:</p>

<p><img src="/images/deep_shallow_copy-3.png"></p>


		
		<a href="/blog/2013/07/09/deep-copy-and-shallow-copy/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-09T19:17:00-06:00" pubdate data-updated="true">Jul 9th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/09/java-string-reside/">
		
			Java中的字符串驻留</a>
	</h2>
	<div class="entry-content">
		<p>最近在工作的时候，一句再正常不过的代码String a = “hello” + “world”;被改成了new StringBuilder().append(“hello”).append(“world”)；当时就比较疑惑这样做的好处，后来到网上查找了一番之后才清楚这与Java中的字符串驻留机制有关，那么什么是驻留呢？</p>


		
		<a href="/blog/2013/07/09/java-string-reside/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-09T19:11:00-06:00" pubdate data-updated="true">Jul 9th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/09/apprenticeship-pattern/">
		
			Apprenticeship Pattern读书笔记</a>
	</h2>
	<div class="entry-content">
		<p>花2个星期读完了这本书，作者是一名前ThoughtWorker，所以书里谈到的很多概念还是很清楚。</p>

<p>书本身非常好，里面谈到了从一名软件小工到专家的成长方法，这些方法都是读者能够拿之能用的。</p>


		
		<a href="/blog/2013/07/09/apprenticeship-pattern/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-09T19:06:00-06:00" pubdate data-updated="true">Jul 9th, 2013</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/technology/'>technology</a>

</div>


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/09/recursion/">
		
			递归的执行过程</a>
	</h2>
	<div class="entry-content">
		<p>这个问题困惑了我好久，从当初学习计算机开始就没有弄明白这个过程，只听说过能用迭代取代递归的地方就用迭代，因为递归很容易引起内存泄露。不过，作为一名专业的程序员，了解这些东西都是必不可少的，所以我今天就把它记录下来。 我们拿一个简单的程序来作为例子：</p>


		
		<a href="/blog/2013/07/09/recursion/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-09T18:42:00-06:00" pubdate data-updated="true">Jul 9th, 2013</time></div>
	


</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/07/09/project-euler/">
		
			Project Euler 15题解惑</a>
	</h2>
	<div class="entry-content">
		<p>这个题目困惑了本人很久，想过各种方法。不是因为脑容量不够而导致处理问题的栈不足而放弃，或者就是根本对上述的想法非常质疑，而又找不到更好的方法以致陷入不断的困惑中。最后还是一番google，找到了问题的解决方法，之所以要记下来，是因为在这道题上我又学习了一种新的解决问题的方法。我姑且称之为“归纳法” + “倒推法”。</p>


		
		<a href="/blog/2013/07/09/project-euler/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  



<time datetime="2013-07-09T18:28:00-06:00" pubdate data-updated="true">Jul 9th, 2013</time></div>
	


</div>
</article>


</div>
	<footer id="footer" class="inner">Copyright &copy; 2015
 李秋实 
<br>
Powered by Octopress.
</footer>
	

</body>
</html>
